diff --git a/async/cohttp_async.ml b/async/cohttp_async.ml
index 94e5bdd..e827ee4 100644
--- a/async/cohttp_async.ml
+++ b/async/cohttp_async.ml
@@ -62,7 +62,11 @@ end
 
 let pipe_of_body read_chunk ic =
   let open Cohttp.Transfer in
-  Pipe.init (fun writer ->
+  let (rd, wr) = Pipe.create () in
+  let monitor = Monitor.create () in
+  let finished = Ivar.create () in
+  upon (Monitor.get_next_error monitor) (fun _ -> Ivar.fill_if_empty finished ());
+  Scheduler.within ~monitor (fun () ->
     Deferred.repeat_until_finished () (fun () ->
       read_chunk ic >>= function
       | Chunk buf ->
@@ -75,12 +79,19 @@ let pipe_of_body read_chunk ic =
          * done by a request handler to signal that it does not need to
          * inspect the remainder of the body to fulfill the request.
         *)
-        Pipe.write_when_ready writer ~f:(fun write -> write buf)
+        Pipe.write_when_ready wr ~f:(fun write -> write buf)
         >>| fun _ -> `Repeat ()
       | Final_chunk buf ->
-        Pipe.write_when_ready writer ~f:(fun write -> write buf)
+        Pipe.write_when_ready wr ~f:(fun write -> write buf)
         >>| fun _ -> `Finished ()
-      | Done -> return (`Finished ())))
+      | Done -> return (`Finished ())
+    )
+    >>> fun () ->
+    (* NB: we do /not/ close the pipe if there's an exn *)
+    Pipe.close wr;
+    Ivar.fill_if_empty finished ()
+  );
+  (rd, Ivar.read finished)
 
 module Body = struct
   module B = Cohttp.Body
@@ -162,20 +173,36 @@ module Client = struct
     | `Ok res ->
       (* Build a response pipe for the body *)
       let reader = Response.make_body_reader res ic in
-      let pipe = pipe_of_body Response.read_body_chunk reader in
-      (res, pipe)
+      let (pipe, finished) = pipe_of_body Response.read_body_chunk reader in
+      (res, pipe, finished)
 
   let request ?interrupt ?ssl_config ?(body=`Empty) req =
     (* Connect to the remote side *)
     Net.connect_uri ?interrupt ?ssl_config req.Request.uri
     >>= fun (ic,oc) ->
-    Request.write (fun writer -> Body.write Request.write_body body writer) req oc
-    >>= fun () ->
-    read_request ic >>| fun (resp, body) ->
-    don't_wait_for (
-      Pipe.closed body >>= fun () ->
-      Deferred.all_ignore [Reader.close ic; Writer.close oc]);
-    (resp, `Pipe body)
+    let interrupt =
+      match interrupt with
+      | None -> Deferred.never ()
+      | Some x -> x
+    in
+    let teardown () =
+      don't_wait_for (Reader.close ic);
+      don't_wait_for (Writer.close oc)
+    in
+    upon interrupt teardown;
+    let res =
+      Monitor.try_with (fun () ->
+        Request.write (fun writer -> Body.write Request.write_body body writer) req oc
+        >>= fun () ->
+        read_request ic
+      )
+    in
+    Deferred.any [ res; (interrupt >>| fun () -> Error (Failure "interrupted")) ]
+    >>| function
+    | Error exn -> teardown (); raise exn
+    | Ok (resp, body, body_finished) ->
+      upon body_finished teardown;
+      (resp, `Pipe body)
 
   let callv ?interrupt ?ssl_config uri reqs =
     let reqs_c = ref 0 in
@@ -193,7 +220,7 @@ module Client = struct
       if Pipe.is_closed reqs && (!resp_c >= !reqs_c) then
         return `Eof
       else
-        ic |> read_request >>| fun (resp, body) ->
+        ic |> read_request >>| fun (resp, body, _) ->
         incr resp_c;
         last_body_drained := Pipe.closed body;
         `Ok (resp, `Pipe body)
@@ -271,7 +298,7 @@ module Server = struct
     | `No | `Unknown -> (`Empty, Deferred.unit)
     | `Yes -> (* Create a Pipe for the body *)
       let reader = Request.make_body_reader req rd in
-      let pipe = pipe_of_body Request.read_body_chunk reader in
+      let (pipe, _) = pipe_of_body Request.read_body_chunk reader in
       (`Pipe pipe, Pipe.closed pipe)
 
   let handle_client handle_request sock rd wr =
