diff --git a/async/cohttp_async.ml b/async/cohttp_async.ml
index 94e5bdd..f860ee9 100644
--- a/async/cohttp_async.ml
+++ b/async/cohttp_async.ml
@@ -62,7 +62,10 @@ end
 
 let pipe_of_body read_chunk ic =
   let open Cohttp.Transfer in
-  Pipe.init (fun writer ->
+  let monitor = Monitor.create () in
+  let finished = Ivar.create () in
+  upon (Monitor.get_next_error monitor) (fun _ -> Ivar.fill_if_empty finished ());
+  Scheduler.within ~monitor (fun () ->
     Deferred.repeat_until_finished () (fun () ->
       read_chunk ic >>= function
       | Chunk buf ->
@@ -80,7 +83,14 @@ let pipe_of_body read_chunk ic =
       | Final_chunk buf ->
         Pipe.write_when_ready writer ~f:(fun write -> write buf)
         >>| fun _ -> `Finished ()
-      | Done -> return (`Finished ())))
+      | Done -> return (`Finished ())
+    )
+    >>> fun () ->
+    (* NB: we do /not/ close the pipe if there's an exn *)
+    Pipe.close wr;
+    Ivar.fill_if_empty finished ()
+  );
+  (rd, Ivar.read finished)
 
 module Body = struct
   module B = Cohttp.Body
@@ -169,13 +179,29 @@ module Client = struct
     (* Connect to the remote side *)
     Net.connect_uri ?interrupt ?ssl_config req.Request.uri
     >>= fun (ic,oc) ->
-    Request.write (fun writer -> Body.write Request.write_body body writer) req oc
-    >>= fun () ->
-    read_request ic >>| fun (resp, body) ->
-    don't_wait_for (
-      Pipe.closed body >>= fun () ->
-      Deferred.all_ignore [Reader.close ic; Writer.close oc]);
-    (resp, `Pipe body)
+    let interrupt =
+      match interrupt with
+      | None -> Deferred.never ()
+      | Some x -> x
+    in
+    let teardown () =
+      don't_wait_for (Reader.close ic);
+      don't_wait_for (Writer.close oc)
+    in
+    upon interrupt teardown;
+    let res =
+      Monitor.try_with (fun () ->
+        Request.write (fun writer -> Body.write Request.write_body body writer) req oc
+        >>= fun () ->
+        read_request ic
+      )
+    in
+    Deferred.any [ res; (interrupt >>| fun () -> Error (Failure "interrupted")) ]
+    >>| function
+    | Error exn -> teardown (); raise exn
+    | Ok (resp, body, body_finished) ->
+      upon body_finished teardown;
+      (resp, body)
 
   let callv ?interrupt ?ssl_config uri reqs =
     let reqs_c = ref 0 in
